---
layout: post
title: Java笔试面试（1）Java基本概念
tags: ["Java"]
categories: 笔试面试
date: 2018-06-08 13:34:00
cover: http://image.wufazhuce.com/FomuanowzzuLG4FXJpQqcrQpp5YM
---

#### 1. Java语言的优点：

- Java是纯面向对象语言
- 平台无关性
- Java提供了很多内置的类库（多线程支持、网络通信支持、垃圾回收器）
- 提供了对Web开发的支持
- 具有较好的安全性和健壮性
- 去除了C++中难以理解、容易混淆的特性，如头文件、指针、运算符重载、多重继承等

#### 2. Java与C++有什么异同

同：都是面向对象语言，都使用了面向对象思想（封装、继承、多态等）
异：

| Java       |   C++   |
| :--------: | :------: |
| 解释型语言；程序源码经过Java编译器编译成字节码，然后由JVM解释执行；Java执行速度更慢   |  为编译型语言；源代码经过编译和链接后生成可执行的二进制代码，不能跨平台  |
|Java 是纯面向对象语言，所有代码必须在类中进行实现，除基本数据类型外，所有类型都是类。不存在全局变量或全局函数|C++兼具面向过程与面向对象的特点，可以定义全局变量和全局函数|
|没有指针，代码更加安全|有指针|
|不支持多重继承，引入接口实现多重继承的功能|支持多重继承|
|提供了垃圾回收器来实现垃圾自动回收，不需要程序显式地管理内存的分配|需要在程序中显式管理内存的分配|
|不支持运算符重载|支持运算符重载|
|使用import引入库|支持预处理|
|不支持默认函数参数|支持默认函数参数|
|不支持goto语句（但goto是保留关键字）|支持goto语句|
|Java提供了一些标准库|依靠非标准的、其他厂商提供的库|


#### 3. public static void main(String [] args) 这个方法的作用

main()方法是Java程序的入口，JVM在运行程序时，会先查找main() 方法。必须用public、static修饰、返回值必须为void，参数必须是String [] 类型，还可以加上final、synchronized来修饰，不能使用abstract来修饰。 public和static的顺序可以调换。

#### 4. Java程序初始化的过程

3个原则：
① 静态对象（变量）优于非静态对象（变量）
② 父类优先于子类进行初始化
③ 按照成员变量的定义顺序进行初始化

顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。

#### 5. 权限修饰符的作用域

| 修饰符      |    当前类 |   同一包下的类   |子类|其他包中的类|
| :--------: | :--------:| :------: |
| public    |   √ |   √  | √| √|
|protected|  √|  √ |  √ | |
|default| √ | √ |   ||
|private| √| | | |

private 和protected不能用来修饰类。（只有public、abstract、final可以用来修饰类）

#### 6. 关于构造函数

构造函数用来在对象实例化时初始化对象的成员变量。
特点：
- 必须与类名相同，不能有返回值，也不能为void
- 一个类可以有多个构造函数（可以重载），如果没有写构造函数，在编译时，编译器会自动加上一个无参的空的构造函数，如果写了构造函数，编译器就不会加无参的构造函数
- 构造函数总是伴随着new一起调用。必须由系统调用，且只执行一次。
- 子类可以使用super关键字来调用父类构造函数。

#### 7. clone() 方法的使用

每个new语句返回的都是一个指针的引用。
Java在处理基本数据类型时，采用按值传递（传递的是输入参数的一个复制）；除此之外，都是采用按引用传递（传递的是输入对象的一个引用）。

对于需要从某个已有的对象A创建出另一个与A相同状态的对象Ｂ，但是对Ｂ的修改不能影响Ａ，普通的赋值操作无法实现，可以使用clone（）方法来实现。

步骤：
1. 首先让该类实现Cloneable接口，Cloneable是一个标识接口，没有任何接口方法。
2. 在类中重写clone（）方法。
3. 在clone（）方法中调用super.clone()，如果该类中的成员变量有引用类型，则对每个引用类型的变量进行深复制。**o.arr = this.getArr().clone()**。
4. 返回新的克隆体的对象。

引申：浅复制与深复制

| 浅复制       |   深复制   |
| :--------:| :------: |
| 被复制对象的所有对象都含有与原来对象相同的值，而所有对其他对象的引用仍然指向原来的对象    |  深复制把复制对象所引用的对象都复制了一遍。  |

![14328926.jpg](https://i.loli.net/2018/11/06/5be1894818494.jpg)

一个clone（）方法的实现（包含深复制）：

```
import java.util.Date;

public class Student implements Cloneable{
	private int age;
	private Date birth;
	
	public void setAge(int age){
		this.age = age;
	}
	public int getAge(){
		return age;
	}
	public void setBirth(Date birth){
		this.birth = birth;
	}
	public Date getBirth(){
		return birth;
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		Student s = null;
		//调用super.clone()方法
		s = (Student) super.clone();
		//进行深复制
		s.birth =  (Date) this.getBirth().clone();
		return s;
	}
}
```

#### 8. 反射机制

反射机制是Java中一个非常重要的特性，他允许程序在运行时进行自我检查，同时也允许对其内部的成员进行操作。反射能够实现在运行时对类进行装载，因此可以增加程序灵活性，但是不恰当地使用反射机制，也会严重影响系统的性能。

反射的功能：得到一个对象所属的类；获取一个类的所有成员变量和方法；在运行时创建对象，在运行时调用对象的方法。

Class 是一个特殊的类，所有的类抽象成Class类。
获取Class的方法：
- Class.forName()
- 类名.class
- 实例.getClass()

Java创建对象的方法（**4种**）：
1. 通过new语句实例化一个对象
2. 通过反射机制创建一个对象
3. 通过clone（）方法创建一个对象
4. 通过反序列化的方式创建

#### 9. package的作用

- 提供多层命名空间，解决命名冲突
- 对类按功能进行分类，使项目的组织更加清晰











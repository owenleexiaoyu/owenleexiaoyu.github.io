<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- Google Analytics -->
  

  <!-- Baidu Tongji -->
  

  <!-- Baidu Push -->
  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc">
  <meta name="baidu-site-verification" content="PpzM9WxOJU">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="做一山花易，成为海树难。">
  <meta name="keyword" content="haishu,海树,owenlee,Blog">
  <link rel="shortcut icon" href="/img/avatar/fish.png">

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>

  
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/widget.css">
    <link rel="stylesheet" href="/css/rocket.css">
    <link rel="stylesheet" href="/css/signature.css">
    <link rel="stylesheet" href="/css/catalog.css">
    <link rel="stylesheet" href="/css/livemylife.css">

    
      <!-- wave start -->
      <link rel="stylesheet" href="/css/wave.css">
      <!-- wave end -->
    

    
      <!-- top start (article top hot config) -->
      <link rel="stylesheet" href="/css/top.css">
      <!-- top end -->
    

    

    
      <!-- viewer start (Picture preview) -->
      <link rel="stylesheet" href="/css/viewer.min.css">
      <!-- viewer end -->
    

    

    

    

    
      <!-- gitalk start -->
      <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
      <link rel="stylesheet" href="/css/gitalk.css">
      <!-- gitalk end -->
    
  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
  href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="http://yoursite.com/2021/03/02/kotlin-learning-16-generic/">
  <title>
    
      Kotlin 修炼手册（16）泛型 - 海树
    
  </title>
</head>


<!-- hack iOS CSS :active style -->

	<body ontouchstart="" class="body--light">


		<!-- ThemeColor -->
		

		<!-- Gitter -->
		

		<!-- Navigation (contains search)-->
		<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">海树</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux: <nav>'s height woule be hold on by its content. so, when navbar scale out, the <nav> will cover tags. also mask any touch event of tags, unfortunately. -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">HOME</a>
          </li>

          
          
          
          
          <li>
            <a href="/categories/">
              
              CATEGORIES
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/about/">
              
              ABOUT
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/tags/">
              
              TAGS
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/archive/">
              
              ARCHIVES
              
              
            </a>
          </li>
          
          

          

          <!-- LangSelect -->
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>

<script>
  // Drop Bootstarp low-performance Navbar Use customize navbar with high-quality material design animation in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


		<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
		<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <style type="text/css">
    .body--light {
      /* intro-header */
      --intro-header-background-image-url-home: url('/img/header_img/home_bg.jpg');
      --intro-header-background-image-url-post: url('');
      --intro-header-background-image-url-page: url('/img/header_img/archive_bg2.jpg');
    }
    .body--dark {
      --intro-header-background-image-url-home: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/home_bg.jpg');
      --intro-header-background-image-url-post: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('');
      --intro-header-background-image-url-page: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/archive_bg2.jpg');
    }

    header.intro-header {
       /*post*/
        background-image: var(--intro-header-background-image-url-post);
        /* background-image: url(''); */
      
    }

    
  </style>





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/tags/#Kotlin" title="Kotlin">Kotlin</a>
              
            </div>
            <h1>Kotlin 修炼手册（16）泛型</h1>
            <h2 class="subheading"></h2>
            <span class="meta">
              Posted by Owen Lee on
              2021-03-02
            </span>


            
            


          </div>
          
        </div>
      </div>
    </div>
  </div>

  
  <!-- waveoverlay start -->
  <div class="preview-overlay">
    <svg class="preview-waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
      <defs>
        <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
      </defs>
      <g class="preview-parallax">
        <use xlink:href="#gentle-wave" x="48" y="0" fill=var(--gentle-wave1)></use>
        <use xlink:href="#gentle-wave" x="48" y="3" fill=var(--gentle-wave2)></use>
        <use xlink:href="#gentle-wave" x="48" y="5" fill=var(--gentle-wave3)></use>
        <use xlink:href="#gentle-wave" x="48" y="7" fill=var(--gentle-wave)></use>
      </g>
    </svg>
  </div>
  <!-- waveoverlay end -->
  

</header>



		<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
		<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <p>这篇文章来写一下 Kotlin 中的泛型。</p>
<h2 id="章节大纲"><a href="#章节大纲" class="headerlink" title="章节大纲"></a>章节大纲</h2><ul>
<li>泛型是什么</li>
<li>Java 中的泛型</li>
<li>Kotlin 中的泛型</li>
</ul>
<h2 id="泛型是什么"><a href="#泛型是什么" class="headerlink" title="泛型是什么"></a>泛型是什么</h2><p>我们知道在 ArrayList 集合中，是用了一个 Object 数组来存储数据，这样就可以存储所有的类型。这样的设计在使用时会出现一个问题，就是我们不能保证里面每个 item 都是同一种数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们有这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = new ArrayList();</span><br><span class="line">list.add(&quot;abc&quot;);</span><br><span class="line">list.add(123);</span><br><span class="line">item1 = (String)list.get(0)</span><br><span class="line">item2 = (String)list.get(1)</span><br></pre></td></tr></table></figure>

<p>在获取下标为 1 的 item 并强转成 String 类型时，就会出现数据类型转化错误。<br>为了解决这个问题，我们可以给存储 String 类型定义一个专门的 ArrayList：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在编译时，list.add(123) 就会直接报错，可以保证 ArrayList 中都是同一种类型。<br>同样地，想要一个只存储 Integer、Float、Person（自定义的类）类型的数据时，就需要再定义一个 IntegerArrayList、FloatArrayList、PersonArrayList，而这显然是不切实际的。</p>
<p>在这种情况下，泛型就出现了。</p>
<p><strong>那什么是泛型呢？</strong></p>
<p>泛型是指<code>参数化类型</code>，把具体的类型泛化，定义时用符号来指代类型，实际使用时再传入确定的类型。泛型其实就是定义了一种<strong>模板</strong>来适应任意类型，它的好处就是在使用时不必做类型强制转换，它通过编译器对类型进行检查保证。泛型可以用在类、接口、方法中，分别被称为泛型类，泛型接口、泛型方法。</p>
<p>再来看前面的例子，我们给 ArrayList 加上泛型 E：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用时，存储 String 和 Integer 类型的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只存储 String 类型</span></span><br><span class="line">ArrayList&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">"abc"</span>);  <span class="comment">// OK </span></span><br><span class="line">stringList.add(<span class="number">123</span>);    <span class="comment">// 编译器会报错</span></span><br><span class="line">item1 = stringList.get(<span class="number">0</span>) <span class="comment">// 这里不需要强制类型转换</span></span><br><span class="line"><span class="comment">// 只存储 Integer 类型</span></span><br><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">intList.add(<span class="string">"abc"</span>);  <span class="comment">// 编译器会报错</span></span><br><span class="line">intList.add(<span class="number">123</span>);    <span class="comment">// OK</span></span><br><span class="line">item2 = intList.get(<span class="number">0</span>) <span class="comment">// 这里不需要强制类型转换</span></span><br></pre></td></tr></table></figure>

<h2 id="Java-中的泛型"><a href="#Java-中的泛型" class="headerlink" title="Java 中的泛型"></a>Java 中的泛型</h2><h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>泛型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<p>例如下面这个简单的泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">    <span class="comment">// key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义的泛型类，<strong>并不一定要传入泛型类型实参</strong>。在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，这时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> Generic(<span class="string">"111111"</span>);</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> Generic(<span class="number">4444</span>);</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> Generic(<span class="number">55.55</span>);</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> Generic(<span class="keyword">false</span>);</span><br><span class="line">System.out.println(<span class="string">"key is "</span> + generic.getKey());</span><br><span class="line">System.out.println(<span class="string">"key is "</span> + generic1.getKey());</span><br><span class="line">System.out.println(<span class="string">"key is "</span> + generic2.getKey());</span><br><span class="line">System.out.println(<span class="string">"key is "</span> + generic3.getKey());</span><br><span class="line"><span class="comment">// 运行结果为</span></span><br><span class="line">key is <span class="number">111111</span></span><br><span class="line">key is <span class="number">4444</span></span><br><span class="line">key is <span class="number">55.55</span></span><br><span class="line">key is <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：泛型的类型参数只能是类类型，不能是基本数据类型，如果是 int、float，需要变成相应的装箱类。</p>
</blockquote>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>泛型还可以用在接口上，称为泛型接口，定义及使用和泛型类基本相同。</p>
<p>例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回负数: 当前实例比参数o小</span></span><br><span class="line"><span class="comment">     * 返回 0: 当前实例与参数o相等</span></span><br><span class="line"><span class="comment">     * 返回正数: 当前实例比参数o大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>泛型方法是在调用方法的时候指明泛型的具体类型。</p>
<p>看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间的 &lt;T&gt; 非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">    T instance = tClass.newInstance();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看一个更全的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">// 这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型</span></span><br><span class="line">        <span class="comment">// 所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法是有问题的，编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = key</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;E&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型E</span></span><br><span class="line"><span class="comment">     * 这个E可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">show</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,表明了这是一个可以处理泛型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型的特性"><a href="#泛型的特性" class="headerlink" title="泛型的特性"></a>泛型的特性</h3><p><strong>泛型只在编译阶段有效</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    System.out.println(<span class="string">"类型相同"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">类型相同</span><br></pre></td></tr></table></figure>

<p>Java 中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。泛型信息不会进入到运行时阶段。<br><strong>Java 中的泛型具有「不可变性 Invariance」</strong>。来看这样一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;View&gt; viewList = new List&lt;TextView&gt;(); // 这里的赋值操作会失败</span><br></pre></td></tr></table></figure>

<p>Java 里面认为 <code>List&lt;TextView&gt;</code> 和 <code>List&lt;View&gt;</code> 类型并不一致，也就是说，子类的泛型（List&lt; Button&gt;）不属于泛型（List&lt; TextView&gt;）的子类。<br>正是因为有编译期类型擦除，所以为了保证类型安全，不允许这样赋值。</p>
<h3 id="泛型上下界和通配符"><a href="#泛型上下界和通配符" class="headerlink" title="泛型上下界和通配符"></a>泛型上下界和通配符</h3><p>前面提到，Java 的泛型具有不可变性，子类的泛型不属于泛型的子类。</p>
<p>使用泛型时，可以为传入的泛型类型实参进行上下边界的限制，这样就可以突破上述不可变性的限制，但同时在使用上也会有新的限制。</p>
<h4 id="上边界"><a href="#上边界" class="headerlink" title="上边界"></a>上边界</h4><p>为泛型添加上边界，即传入的类型实参必须是指定类型或指定类型的子类型：用 <strong>&lt;? extends 指定类型&gt;</strong> 表示，可以使泛型具有 <strong>「协变性 Covariance」</strong></p>
<p>例如上面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends View&gt; viewList = <span class="keyword">new</span> List&lt;TextView&gt;(); <span class="comment">// 这样的赋值是可以的</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>这里的 ? 是通配符，表示是个不确定的类型</li>
<li>这里的 extends 限制了类型的上界，但和类继承的 extends 有些区别：<ul>
<li>包含定义上界类型本身</li>
<li>上界类型可以是接口</li>
</ul>
</li>
</ol>
</blockquote>
<p>有协变性的泛型只能作为生产者，也就是只能读，不能写。</p>
<p>看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends View&gt; viewList = <span class="keyword">new</span> List&lt;TextView&gt;(); <span class="comment">// 这样的赋值是可以的</span></span><br><span class="line">View v = viewList.get(<span class="number">0</span>); <span class="comment">// 可以读取</span></span><br><span class="line">viewList.add(<span class="keyword">new</span> TextView()); <span class="comment">// 报错，不可以写入</span></span><br></pre></td></tr></table></figure>

<p>因为有上界限制，viewList 里的元素一定是 View 或 View 的子类型，根据多态的特性，是可以赋值给父类的引用的，所以读取操作没有问题。<br>在 add 时，因为 List&lt;? extends View&gt; 代表一个不确定的类型，有可能是 List<view> 也可能是 List<textview>，所以在添加时，编译器无法确定是否满足类型安全，所以直接报错。</textview></view></p>
<h4 id="下边界"><a href="#下边界" class="headerlink" title="下边界"></a>下边界</h4><p>为泛型添加下边界，即传入的类型实参必须是指定类型或指定类型的父类型：用<strong>&lt;? super 指定类型&gt;</strong>表示，可以使泛型具有<strong>「逆变性 Contravariance」。</strong></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> TextView&gt; tvList = <span class="keyword">new</span> ArrayList&lt;TextView&gt;(); <span class="comment">// 本身</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> TextView&gt; tvList = <span class="keyword">new</span> ArrayList&lt;View&gt;();  <span class="comment">// 直接父类</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> TextView&gt; tvList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();  <span class="comment">// 间接父类</span></span><br></pre></td></tr></table></figure>

<p>有逆变性的泛型一般用来作为消费者，只能写，不能读。（这里的不能读是指<code>不能类型安全地读取出来</code>，拿到的都是 Object 对象，要类型强转也是可以的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> TextView&gt; tvList = <span class="keyword">new</span> ArrayList&lt;View&gt;(); <span class="comment">// 这样的赋值是可以的</span></span><br><span class="line">Object o = viewList.get(<span class="number">0</span>); <span class="comment">// get() 获取到的是Object类型的对象</span></span><br><span class="line">viewList.add(<span class="keyword">new</span> View());   <span class="comment">// add操作可以</span></span><br></pre></td></tr></table></figure>

<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>类型通配符一般是使用 <code>?</code> 代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是 List&lt; String&gt;, List&lt; Integer&gt; 等所有 List&lt;具体类型实参&gt; 的父类。<code>?</code> 的含义其实是 <code>? extends Object</code>。</p>
<blockquote>
<p>注意：这里的 ? 是类型实参，而不是类型形参，也就是说，这里的 ? 和 String、Integer、Person 等是一样的，是一种真实的类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">        </span><br><span class="line">        name.add(<span class="string">"icon"</span>);</span><br><span class="line">        age.add(<span class="number">18</span>);</span><br><span class="line">        number.add(<span class="number">314</span>);</span><br><span class="line"> </span><br><span class="line">        getData(name);</span><br><span class="line">        getData(age);</span><br><span class="line">        getData(number);</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(List&lt;?&gt; data)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"data :"</span> + data.get(<span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">data :icon</span><br><span class="line">data :<span class="number">18</span></span><br><span class="line">data :<span class="number">314</span></span><br></pre></td></tr></table></figure>

<h2 id="Kotlin-中的泛型"><a href="#Kotlin-中的泛型" class="headerlink" title="Kotlin 中的泛型"></a>Kotlin 中的泛型</h2><p>Kotlin 中的泛型用法和 Java 基本是一样的。</p>
<h4 id="泛型类-1"><a href="#泛型类-1" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Box&lt;T&gt;(t: T) &#123;</span><br><span class="line">    <span class="keyword">var</span> value: T = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法-1"><a href="#泛型方法-1" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>类型参数 <strong><t></t></strong> 要放在函数名的前面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; boxIn(value: T) = Box(value)</span><br><span class="line"><span class="comment">// 以下都是合法语句</span></span><br><span class="line">val box4 = boxIn&lt;Int&gt;(<span class="number">1</span>)</span><br><span class="line">val box5 = boxIn(<span class="number">1</span>)     <span class="comment">// 👈 编译器会进行类型推断</span></span><br></pre></td></tr></table></figure>

<h4 id="泛型上边界"><a href="#泛型上边界" class="headerlink" title="泛型上边界"></a>泛型上边界</h4><p>Kotlin 中上边界用 <code>out</code> 关键字表示，对应 Java 中的 <code>? extends</code>，具有协变性，用于生产者，只能读不能写，只能用作输出，可以作为返回值类型但是无法作为入参的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val tvList: List&lt;out TextView&gt; = ArrayList&lt;Button&gt;() <span class="comment">// 👈 out</span></span><br></pre></td></tr></table></figure>

<p>以一个生产者为例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">produce</span><span class="params">()</span>: T </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">val producer: Producer&lt;out TextView&gt; = Producer&lt;Button&gt;()</span><br><span class="line">val textView: TextView = producer.produce() <span class="comment">// 👈 相当于 'List' 的 `get`</span></span><br></pre></td></tr></table></figure>

<h4 id="泛型下边界"><a href="#泛型下边界" class="headerlink" title="泛型下边界"></a>泛型下边界</h4><p>Kotlin 中下边界用 <code>in</code> 关键字表示，对应 Java 中的 <code>? super</code>， 使泛型具有逆变性，用于消费者，只能写不能读，只能用作输入，可以作为入参的类型但是无法作为返回值的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val tvList: List&lt;in TextView&gt; = ArrayList&lt;View&gt;() <span class="comment">// 👈 in</span></span><br></pre></td></tr></table></figure>

<p>以一个消费者为例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">consume</span><span class="params">(t: T)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">val consumer: Consumer&lt;in Button&gt; = Consumer&lt;TextView&gt;()</span><br><span class="line">consumer.consume(Button(context)) <span class="comment">// 👈 相当于 'List' 的 'add'</span></span><br></pre></td></tr></table></figure>

<h4 id="声明处的-in-和-out"><a href="#声明处的-in-和-out" class="headerlink" title="声明处的 in 和 out"></a>声明处的 in 和 out</h4><p>在前面的例子中，在声明 Producer 的时候已经确定了泛型 T 只会作为输出来用，但是每次都需要在使用的时候加上 <code>out TextView</code> 来支持协变，写起来很麻烦。Kotlin 提供了另一种写法：</p>
<p>在声明类的时候，给泛型符号加上 <code>out</code> 关键字，表明泛型参数 T 只会用来输出，在使用的时候就不用额外加 out 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//             👇</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>&lt;<span class="title">out</span> <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">produce</span><span class="params">()</span>: T </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">val producer: Producer&lt;TextView&gt; = Producer&lt;Button&gt;() <span class="comment">// 👈 这里不写 out 也不会报错</span></span><br><span class="line">val producer: Producer&lt;out TextView&gt; = Producer&lt;Button&gt;() <span class="comment">// 👈 out 可以写但没必要</span></span><br></pre></td></tr></table></figure>

<p>与 out 一样，可以在声明类的时候，给泛型参数加上 <code>in</code> 关键字，来表明这个泛型参数 T 只用来输入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//             👇</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>&lt;<span class="title">in</span> <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">consume</span><span class="params">(t: T)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">val consumer: Consumer&lt;Button&gt; = Consumer&lt;TextView&gt;() <span class="comment">// 👈 这里不写 in 也不会报错</span></span><br><span class="line">val consumer: Consumer&lt;in Button&gt; = Consumer&lt;TextView&gt;() <span class="comment">// 👈 in 可以写但没必要</span></span><br></pre></td></tr></table></figure>

<h4 id="泛型通配符-1"><a href="#泛型通配符-1" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>前面提到 Java 中单个 <code>?</code> 号能作为泛型通配符使用，相当于 <code>? extends Object</code>。</p>
<p>它在 Kotlin 中有等效的写法：<code>*</code> 号，相当于 <code>out Any</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list: List&lt;*&gt;</span><br></pre></td></tr></table></figure>

<h4 id="where-关键字"><a href="#where-关键字" class="headerlink" title="where 关键字"></a>where 关键字</h4><p>上面提到 Java 中泛型上边界用 extends 关键字，如果同时有多个上界时，用 <code>&amp;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                            👇 T 的类型必须同时是 Animal 和 Food 的子类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Animal</span> &amp; <span class="title">Food</span>&gt;</span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Kotlin 中的等效写法是使用 <code>where</code> 关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                👇</span></span><br><span class="line">class Monster&lt;T&gt; where T: Animal, T: Food &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reified-关键字"><a href="#reified-关键字" class="headerlink" title="reified 关键字"></a>reified 关键字</h4><p>在 Java 中因为在编译期间类型被擦除了，所以在运行期不能获取泛型的确切类型。比如在运行期不能检查一个对象是否是泛型 T 的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printIfTypeMatch</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item <span class="keyword">instanceof</span> T) &#123; <span class="comment">// 👈 IDE 会提示错误，illegal generic type for instanceof</span></span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Kotlin 中同样不行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; printIfTypeMatch(item: Any) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item is T) &#123; <span class="comment">// 👈 IDE 会提示错误，Cannot check for instance of erased type: T</span></span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题，在 Java 中的解决方案通常是额外传递一个 <code>Class&lt;T&gt;</code> 类型的参数，然后通过 <code>Class#isInstance</code> 方法来检查：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(Object item, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInstance(item)) &#123;</span><br><span class="line">        <span class="comment">//      👆</span></span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin 中同样可以这么解决，不过还有一个更方便的做法：使用关键字 <code>reified</code> 配合 <code>inline</code> 来解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; printIfTypeMatch(item: Any) &#123;</span><br><span class="line">    if (item is T) &#123; // 👈 这里就不会在提示错误了</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的原理是：</p>
<ul>
<li>inline 内联方法会把这个方法代码复制到调用处进行替换，这时候编译器知道当前的方法中泛型对应的具体类型是什么</li>
<li>reified 关键字就是让编译器把泛型替换为具体类型，从而达到不被擦除的目的</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://kaixue.io/kotlin-generics/" target="_blank" rel="noopener">Kotlin 的泛型 - 扔物线</a></p>
<p><a href="https://www.runoob.com/kotlin/kotlin-generics.html" target="_blank" rel="noopener">Kotlin 泛型 - 菜鸟教程</a></p>
<p><a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></p>


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          <li class="previous">
            <a href="/2021/03/05/kotlin-learning-17-annotation/" data-toggle="tooltip" data-placement="top" title="Kotlin 修炼手册（17）注解">&larr; Previous Post</a>
          </li>
          
          
          <li class="next">
            <a href="/2021/01/03/summary-of-2020/" data-toggle="tooltip" data-placement="top" title="2020 年终总结与 2021 展望">Next Post &rarr;</a>
          </li>
          
        </ul>

        
        <!-- tip start -->
        <!-- tip -->
<!-- tip start -->
<div class="tip">
  <p>
    
      如果您喜欢这篇博客或发现它对您有用，则欢迎发表评论。 也欢迎您分享此博客，以便更多人可以参与。 如果博客中使用的图像侵犯了您的版权，请与作者联系以将其删除。 谢谢！
    
  </p>
</div>
<!-- tip end -->

        <!-- tip end -->
        

        
        <!-- Sharing Srtart -->
        <!-- Social Social Share Post -->
<!-- Docs:https://github.com/overtrue/share.js -->

<div class="social-share" data-initialized="true" data-disabled="tencent ,douban ,qzone ,linkedin ,facebook ,google ,diandian" data-wechat-qrcode-helper="" align="center">
  <ul class="list-inline text-center social-share-ul">
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-twitter">
        <i class="fa fa-twitter fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a class="social-share-icon icon-wechat">
        <i class="fa fa-weixin fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-weibo">
        <i class="fa fa-weibo fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-qq">
        <i class="fa fa-qq fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon" href="mailto:?subject=Kotlin 修炼手册（16）泛型&body=Hi,I found this website and thought you might like it http://yoursite.com/2021/03/02/kotlin-learning-16-generic/">
        <i class="fa fa-envelope fa-1x" aria-hidden="true"></i>
      </a>
    </li>
  </ul>
</div>

<!-- css & js -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"> -->
<script defer="defer" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

        <!-- Sharing End -->
        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

  <!-- gitalk start -->
  <!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

  <div id="gitalk-container"></div>

  
    <!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.js"></script> -->
    <script src="/js/comment/gitalk.js"></script>
  

  <script>
    var gitalk = new Gitalk({
      clientID: '3b44fc2839a6c19bfea7',
      clientSecret: 'b96f2147e01e0d906403b6af8518a8e1f04a46de',
      repo: 'blogcomments',
      owner: 'owenleexiaoyu',
      admin: 'owenleexiaoyu',
      id: 'Tue Mar 02 2021 10:00:00 GMT+0800', // Ensure uniqueness and length less than 50
      distractionFreeMode: false, // Facebook-like distraction free mode
      perPage: 10,
      pagerDirection: 'last',
      createIssueManually: false,
      language: 'en',
      proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    });
    gitalk.render('gitalk-container');

    var gtFolded = () => {
      setTimeout(function () {
        let markdownBody = document.getElementsByClassName("markdown-body");
        let list = Array.from(markdownBody);
        list.forEach(item => {
          if (item.clientHeight > 250) {
            item.classList.add('gt-comment-body-folded');
            item.style.maxHeight = '250px';
            item.title = 'Click to Expand';
            item.onclick = function () {
              item.classList.remove('gt-comment-body-folded');
              item.style.maxHeight = '';
              item.title = '';
              item.onclick = null;
            };
          }
        })
      }, 800);
    }
  </script>

  <!-- gitalk end -->


<!-- 2. gitment comment -->


<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->



      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">FEATURED TAGS</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#Kotlin" title="Kotlin">Kotlin</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
      </div>
    </div>
  </div>
</article>





		<!-- Footer (contains ThemeColor、viewer) -->
		<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          
            <li>
              <a target="_blank" href="https://github.com/owenleexiaoyu">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          

          

          

          

          

          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          Owen Lee
          2022
          <br>
          Theme by
          <a href="http://beantech.org">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a href="https://v-vincen.life/">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>


  <!-- jQuery -->
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <!-- Bootstrap Core JavaScript -->
  <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  <!-- Custom Theme JavaScript -->
  <script type="text/javascript" src="/js/hux-blog.min.js"></script>
  <!-- catalog -->
  <script async="true" type="text/javascript" src="/js/catalog.js"></script>
  <!-- totop(rocket) -->
  <script async="true" type="text/javascript" src="/js/totop.js"></script>

  

  

  

  

  

  






  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  
    <script async="async" type="text/javascript" src="/js/viewer/viewer.min.js"></script>
    <script async="async" type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
  

  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async ("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () { hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if ($('#tag_cloud').length !== 0) { async ("http://yoursite.com/js/jquery.tagcloud.js", function () { $.fn.tagcloud.defaults = { // size: { start: 1, end: 1, unit: 'em' }, color: {
start: '#bbbbee', end: '#0085a1' } }; $('#tag_cloud a').tagcloud(); }) } </script> -->


		<!-- Search -->
		
	</body>
</html>

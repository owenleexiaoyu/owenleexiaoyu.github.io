<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- Google Analytics -->
  

  <!-- Baidu Tongji -->
  

  <!-- Baidu Push -->
  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc">
  <meta name="baidu-site-verification" content="PpzM9WxOJU">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="做一山花易，成为海树难。">
  <meta name="keyword" content="haishu,海树,owenlee,Blog">
  <link rel="shortcut icon" href="/img/avatar/fish.png">

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>

  
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/widget.css">
    <link rel="stylesheet" href="/css/rocket.css">
    <link rel="stylesheet" href="/css/signature.css">
    <link rel="stylesheet" href="/css/catalog.css">
    <link rel="stylesheet" href="/css/livemylife.css">

    

    
      <!-- top start (article top hot config) -->
      <link rel="stylesheet" href="/css/top.css">
      <!-- top end -->
    

    

    
      <!-- viewer start (Picture preview) -->
      <link rel="stylesheet" href="/css/viewer.min.css">
      <!-- viewer end -->
    

    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/themecolor.css">
      <!-- ThemeColor end -->
    

    

    
      <!-- gitalk start -->
      <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
      <link rel="stylesheet" href="/css/gitalk.css">
      <!-- gitalk end -->
    
  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
  href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="http://yoursite.com/2021/03/31/java-apt/">
  <title>
    
      【转载】Java 注解处理器 - 海树
    
  </title>
</head>


<!-- hack iOS CSS :active style -->

	<body ontouchstart="" class="body--light body--dark">


		<!-- ThemeColor -->
		
		<!-- ThemeColor -->
<style type="text/css">
  .body--light {
    --light-mode: none;
    --dark-mode: block;
  }
  .body--dark {
    --light-mode: block;
    --dark-mode: none;
  }
  i.mdui-icon.material-icons.light-mode {
    display: var(--light-mode);
  }
  i.mdui-icon.material-icons.dark-mode {
    display: var(--dark-mode);
  }
</style>
<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons light-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>
<script>
  //getCookieValue
  function getCookieValue(a) {
    var b = document.cookie.match('(^|[^;]+)\\s*' + a + '\\s*=\\s*([^;]+)');
    return b
      ? b.pop()
      : '';
  }
  let themeMode = 'dark';
  if (getCookieValue('sb-color-mode') && (getCookieValue('sb-color-mode') !== themeMode)) {
    let dbody = document.body.classList;
    themeMode === 'dark' ? dbody.remove('body--dark') : dbody.add('body--dark');
  }

  //setCookieValue
  var toggleBtn = document.querySelector(".toggle");
  toggleBtn.addEventListener("click", function () {
    var e = document.body.classList.contains("body--dark");
    var cookieString = e
      ? "dark"
      : "light";
    var exp = new Date();
    exp.setTime(exp.getTime() + 3 * 24 * 60 * 60 * 1000); //3天过期
    document.cookie = "sb-color-mode=" + cookieString + ";expires=" + exp.toGMTString() + ";path=/";
  });
</script>

		

		<!-- Gitter -->
		

		<!-- Navigation (contains search)-->
		<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">海树</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux: <nav>'s height woule be hold on by its content. so, when navbar scale out, the <nav> will cover tags. also mask any touch event of tags, unfortunately. -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">HOME</a>
          </li>

          
          
          <li>
            <a href="/tags/">
              
              TAGS
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/categories/">
              
              CATEGORIES
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/archive/">
              
              ARCHIVES
              
              
            </a>
          </li>
          
          
          
          
          
          <li>
            <a href="/about/">
              
              ABOUT
              
              
            </a>
          </li>
          
          

          

          <!-- LangSelect -->
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>

<script>
  // Drop Bootstarp low-performance Navbar Use customize navbar with high-quality material design animation in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


		<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
		<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <style type="text/css">
    .body--light {
      /* intro-header */
      --intro-header-background-image-url-home: url('/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: url('');
      --intro-header-background-image-url-page: url('/img/header_img/archive_bg2.jpg');
    }
    .body--dark {
      --intro-header-background-image-url-home: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('');
      --intro-header-background-image-url-page: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/archive_bg2.jpg');
    }

    header.intro-header {
       /*post*/
        background-image: var(--intro-header-background-image-url-post);
        /* background-image: url(''); */
      
    }

    
  </style>





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/tags/#Java" title="Java">Java</a>
              
            </div>
            <h1>【转载】Java 注解处理器</h1>
            <h2 class="subheading"></h2>
            <span class="meta">
              Posted by Owen Lee on
              2021-03-31
            </span>


            
            
            <!-- 不蒜子统计 start -->
            <span class="meta" id="busuanzi_container_page_pv">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            <!-- 不蒜子统计 end -->
            


          </div>
          
        </div>
      </div>
    </div>
  </div>

  

</header>



		<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
		<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <p>本文转载自：<a href="https://www.race604.com/annotation-processing/" target="_blank" rel="noopener">https://www.race604.com/annotation-processing/</a></p>
<p>Java中的注解(Annotation)是一个很神奇的东西，特别现在有很多Android库都是使用注解的方式来实现的。一直想详细了解一下其中的原理。很有幸阅读到一篇详细解释编写注解处理器的文章。本文的原文是<a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="noopener">ANNOTATION PROCESSING 101</a>，作者是<a href="http://hannesdorfmann.com/" target="_blank" rel="noopener">Hannes Dorfmann</a>。这是一篇好文，忍不住翻译学习一下。以下是翻译。（注：本文的翻译已经获得了作者 Hannes 的授权。）</p>
<hr>
<p>在这篇文章中，我将阐述怎样写一个注解处理器(Annotation Processor)。在这篇教程中，首先，我将向您解释什么是注解器，你可以利用这个强大的工具做什么以及不能做什么；然后，我将一步一步实现一个简单的注解器。</p>
<h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><p>在开始之前，我们首先申明一个非常重要的问题：我们并不讨论那些在运行时（Runtime）通过反射机制运行处理的注解，而是讨论在编译时（Compile time）处理的注解。</p>
<p>注解处理器（Annotation Processor）是 <strong>javac</strong> 的一个工具，它用来在编译时扫描和处理注解（Annotation）。你可以对自定义注解，并注册相应的注解处理器。到这里，我假设你已经知道什么是注解，并且知道怎么申明一个注解。如果你不熟悉注解，你可以在这 <a href="http://docs.oracle.com/javase/tutorial/java/annotations/index.html" target="_blank" rel="noopener">官方文档</a> 中得到更多信息。注解处理器在Java 5开始就有了，但是从Java 6（2006年12月发布）开始才有可用的 API。过了一些时间，Java 世界才意识到注解处理器的强大作用，所以它到最近几年才流行起来。</p>
<p>一个注解的注解处理器，以 Java 代码（或者编译过的字节码）作为输入，生成文件（通常是<code>.java</code> 文件）作为输出。这具体的含义什么呢？你可以生成 Java 代码！这些生成的 Java 代码是在生成的 .java 文件中，所以你不能修改已经存在的 Java 类，例如向已有的类中添加方法。这些生成的 Java 文件，会同其他普通的手动编写的 Java 源代码一样被 <strong>javac</strong> 编译。</p>
<h2 id="抽象处理器AbstractProcessor"><a href="#抽象处理器AbstractProcessor" class="headerlink" title="抽象处理器AbstractProcessor"></a>抽象处理器<code>AbstractProcessor</code></h2><p>我们首先看一下处理器的 API。每一个处理器都是继承于<code>AbstractProcessor</code>，如下所示：</p>
<pre><code class="java">package com.example;

public class MyProcessor extends AbstractProcessor {

    @Override
    public synchronized void init(ProcessingEnvironment env){ }

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) { }

    @Override
    public Set&lt;String&gt; getSupportedAnnotationTypes() { }

    @Override
    public SourceVersion getSupportedSourceVersion() { }

}</code></pre>
<ul>
<li><code>init(ProcessingEnvironment env)</code>: 每一个注解处理器类都 <strong>必须有一个空的构造函数</strong>。然而，这里有一个特殊的<code>init()</code>方法，它会被注解处理工具调用，并输入<code>ProcessingEnviroment</code>参数。<code>ProcessingEnviroment</code>提供很多有用的工具类<code>Elements</code>, <code>Types</code>和<code>Filer</code>。后面我们将看到详细的内容。</li>
<li><code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</code>: 这相当于每个处理器的主函数<code>main()</code>。你在这里写你的扫描、评估和处理注解的代码，以及生成 Java 文件。输入参数<code>RoundEnviroment</code>，可以让你查询出包含特定注解的被注解元素。后面我们将看到详细的内容。</li>
<li><code>getSupportedAnnotationTypes()</code>: 这里你必须指定，这个注解处理器是注册给哪个注解的。注意，它的返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。换句话说，你在这里定义你的注解处理器注册到哪些注解上。</li>
<li><code>getSupportedSourceVersion()</code>: 用来指定你使用的 Java 版本。通常这里返回<code>SourceVersion.latestSupported()</code>。然而，如果你有足够的理由只支持 Java 6 的话，你也可以返回<code>SourceVersion.RELEASE_6</code>。我推荐你使用前者。</li>
</ul>
<p>在 Java 7 中，你也可以使用注解来代替<code>getSupportedAnnotationTypes()</code>和<code>getSupportedSourceVersion()</code>，像这样：</p>
<pre><code class="java">@SupportedSourceVersion(SourceVersion.latestSupported())
@SupportedAnnotationTypes({
   // 合法注解全名的集合
 })
public class MyProcessor extends AbstractProcessor {

    @Override
    public synchronized void init(ProcessingEnvironment env){ }

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) { }
}</code></pre>
<p>因为兼容的原因，特别是针对 Android 平台，我建议使用重载<code>getSupportedAnnotationTypes()</code>和<code>getSupportedSourceVersion()</code>方法代替 <code>@SupportedAnnotationTypes</code> 和 <code>@SupportedSourceVersion</code>。</p>
<p>接下来的你必须知道的事情是，注解处理器是运行它自己的虚拟机 JVM 中。是的，你没有看错，<strong>javac</strong> 启动一个完整 Java 虚拟机来运行注解处理器。这对你意味着什么？你可以使用任何你在其他 Java 应用中使用的的东西。使用 guava。如果你愿意，你可以使用依赖注入工具，例如 dagger 或者其他你想要的类库。但是不要忘记，即使是一个很小的处理，你也要像其他 Java 应用一样，注意算法效率，以及设计模式。</p>
<h2 id="注册你的处理器"><a href="#注册你的处理器" class="headerlink" title="注册你的处理器"></a>注册你的处理器</h2><p>你可能会问，<em>我怎样将处理器 <code>MyProcessor</code> 注册到 javac 中。你必须提供一个<code>.jar</code>文件。就像其他 *</em>.jar** 文件一样，你打包你的注解处理器到此文件中。并且，在你的 jar 中，你需要打包一个特定的文件 <code>javax.annotation.processing.Processor</code> 到 <code>META-INF/services</code> 路径下。所以，你的.jar文件看起来就像下面这样：</p>
<ul>
<li>MyProcessor.jar</li>
<li><ul>
<li>com</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>example</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>MyProcessor.class</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>META-INF</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>services</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>javax.annotation.processing.Processor</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>打包进 MyProcessor.jar 中的 <code>javax.annotation.processing.Processor</code> 的内容是，注解处理器的合法的全名列表，每一个元素换行分割：</p>
<pre><code class="java">com.example.MyProcessor  
com.foo.OtherProcessor  
net.blabla.SpecialProcessor  </code></pre>
<p>把 <code>MyProcessor.jar</code> 放到你的 buildpath 中，javac 会自动检查和读取 <code>javax.annotation.processing.Processor</code> 中的内容，并且注册 <code>MyProcessor</code> 作为注解处理器。</p>
<h2 id="例子：工厂模式"><a href="#例子：工厂模式" class="headerlink" title="例子：工厂模式"></a>例子：工厂模式</h2><p>是时候来说一个实际的例子了。我们将使用 <strong>maven</strong> 工具来作为我们的编译系统和依赖管理工具。如果你不熟悉 <strong>maven</strong>，不用担心，因为 maven 不是必须的。本例子的完成代码在 <a href="https://github.com/sockeqwe/annotationprocessing101" target="_blank" rel="noopener">Github</a> 上。</p>
<p>开始之前，我必须说，要为这个教程找到一个需要用注解处理器解决的简单问题，实在并不容易。这里我们将实现一个非常简单的工厂模式（不是抽象工厂模式）。这将对注解处理器的 API 做一个非常简明的介绍。所以，这个问题的程序并不是那么有用，也不是一个真实世界的例子。所以在此申明，你将学习关于注解处理过程的相关内容，而不是设计模式。</p>
<p>我们将要解决的问题是：我们将实现一个披萨店，这个披萨店给消费者提供两种披萨（“Margherita”和“Calzone”）以及提拉米苏甜点(Tiramisu)。</p>
<p>看一下如下的代码，不需要做任何更多的解释：</p>
<pre><code class="java">public interface Meal {  
  public float getPrice();
}

public class MargheritaPizza implements Meal {

  @Override public float getPrice() {
    return 6.0f;
  }
}

public class CalzonePizza implements Meal {

  @Override public float getPrice() {
    return 8.5f;
  }
}

public class Tiramisu implements Meal {

  @Override public float getPrice() {
    return 4.5f;
  }
}</code></pre>
<p>为了在我们的披萨店<code>PizzsStore</code>下订单，消费者需要输入餐(Meal)的名字。</p>
<pre><code class="java">public class PizzaStore {

  public Meal order(String mealName) {

    if (mealName == null) {
      throw new IllegalArgumentException(&quot;Name of the meal is null!&quot;);
    }

    if (&quot;Margherita&quot;.equals(mealName)) {
      return new MargheritaPizza();
    }

    if (&quot;Calzone&quot;.equals(mealName)) {
      return new CalzonePizza();
    }

    if (&quot;Tiramisu&quot;.equals(mealName)) {
      return new Tiramisu();
    }

    throw new IllegalArgumentException(&quot;Unknown meal &#39;&quot; + mealName + &quot;&#39;&quot;);
  }

  public static void main(String[] args) throws IOException {
    PizzaStore pizzaStore = new PizzaStore();
    Meal meal = pizzaStore.order(readConsole());
    System.out.println(&quot;Bill: $&quot; + meal.getPrice());
  }
}</code></pre>
<p>正如你所见，在<code>order()</code>方法中，我们有很多的<code>if</code>语句，并且如果我们每添加一种新的披萨，我们都要添加一条新的<code>if</code>语句。但是等一下，使用注解处理和工厂模式，我们可以让注解处理器来帮我们自动生成这些<code>if</code>语句。如此以来，我们期望的是如下的代码：</p>
<pre><code class="java">public class PizzaStore {

  private MealFactory factory = new MealFactory();

  public Meal order(String mealName) {
    return factory.create(mealName);
  }

  public static void main(String[] args) throws IOException {
    PizzaStore pizzaStore = new PizzaStore();
    Meal meal = pizzaStore.order(readConsole());
    System.out.println(&quot;Bill: $&quot; + meal.getPrice());
  }
}</code></pre>
<p><code>MealFactory</code>应该是如下的样子：</p>
<pre><code class="java">public class MealFactory {

  public Meal create(String id) {
    if (id == null) {
      throw new IllegalArgumentException(&quot;id is null!&quot;);
    }
    if (&quot;Calzone&quot;.equals(id)) {
      return new CalzonePizza();
    }

    if (&quot;Tiramisu&quot;.equals(id)) {
      return new Tiramisu();
    }

    if (&quot;Margherita&quot;.equals(id)) {
      return new MargheritaPizza();
    }

    throw new IllegalArgumentException(&quot;Unknown id = &quot; + id);
  }
}</code></pre>
<h2 id="Factory注解"><a href="#Factory注解" class="headerlink" title="@Factory注解"></a><code>@Factory</code>注解</h2><p>你能猜到么：我们想用注解处理器自动生成<code>MealFactory</code>。更一般的说，我们将想要提供一个注解和一个处理器来生成工厂类。</p>
<p>我们先来看一下<code>@Factory</code>注解：</p>
<pre><code class="java">@Target(ElementType.TYPE) @Retention(RetentionPolicy.CLASS)
public @interface Factory {

  /**
   * 工厂的名字
   */
  Class type();

  /**
   * 用来表示生成哪个对象的唯一id
   */
  String id();
}</code></pre>
<p>想法是这样的：我们将使用同样的<code>type()</code>注解那些属于同一个工厂的类，并且用注解的<code>id()</code>做一个映射，例如从<code>&quot;Calzone&quot;</code>映射到<code>&quot;ClzonePizza&quot;</code>类。我们应用<code>@Factory</code>注解到我们的类中，如下：</p>
<pre><code class="java">@Factory(
    id = &quot;Margherita&quot;,
    type = Meal.class
)
public class MargheritaPizza implements Meal {

  @Override public float getPrice() {
    return 6f;
  }
}
@Factory(
    id = &quot;Calzone&quot;,
    type = Meal.class
)
public class CalzonePizza implements Meal {

  @Override public float getPrice() {
    return 8.5f;
  }
}
@Factory(
    id = &quot;Tiramisu&quot;,
    type = Meal.class
)
public class Tiramisu implements Meal {

  @Override public float getPrice() {
    return 4.5f;
  }
}</code></pre>
<p>你可能会问你自己，我们是否可以只把<code>@Factory</code>注解应用到我们的<code>Meal</code>接口上？答案是，注解是不能继承的。一个类<code>class X</code>被注解，并不意味着它的子类<code>class Y extends X</code>会自动被注解。在我们开始写处理器的代码之前，我们先规定如下一些规则：</p>
<ol>
<li>只有类可以被<code>@Factory</code>注解，因为接口或者抽象类并不能用<code>new</code>操作实例化；</li>
<li>被<code>@Factory</code>注解的类，必须至少提供一个公开的默认构造器（即没有参数的构造函数）。否者我们没法实例化一个对象。</li>
<li>被<code>@Factory</code>注解的类必须直接或者间接的继承于<code>type()</code>指定的类型；</li>
<li>具有相同的<code>type</code>的注解类，将被聚合在一起生成一个工厂类。这个生成的类使用<em>Factory</em>后缀，例如<code>type = Meal.class</code>，将生成<code>MealFactory</code>工厂类；</li>
<li><code>id</code>只能是String类型，并且在同一个<code>type</code>组中必须唯一。</li>
</ol>
<h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><p>我将通过添加代码和一段解释的方法，一步一步的引导你来构建我们的处理器。省略号(<code>...</code>)表示省略那些已经讨论过的或者将在后面的步骤中讨论的代码，目的是为了让我们的代码有更好的可读性。正如我们前面说的，我们完整的代码可以在<a href="https://github.com/sockeqwe/annotationprocessing101" target="_blank" rel="noopener">Github</a>上找到。好了，让我们来看一下我们的处理器类<code>FactoryProcessor</code>的骨架：</p>
<pre><code class="java">@AutoService(Processor.class)
public class FactoryProcessor extends AbstractProcessor {

  private Types typeUtils;
  private Elements elementUtils;
  private Filer filer;
  private Messager messager;
  private Map&lt;String, FactoryGroupedClasses&gt; factoryClasses = new LinkedHashMap&lt;String, FactoryGroupedClasses&gt;();

  @Override
  public synchronized void init(ProcessingEnvironment processingEnv) {
    super.init(processingEnv);
    typeUtils = processingEnv.getTypeUtils();
    elementUtils = processingEnv.getElementUtils();
    filer = processingEnv.getFiler();
    messager = processingEnv.getMessager();
  }

  @Override
  public Set&lt;String&gt; getSupportedAnnotationTypes() {
    Set&lt;String&gt; annotataions = new LinkedHashSet&lt;String&gt;();
    annotataions.add(Factory.class.getCanonicalName());
    return annotataions;
  }

  @Override
  public SourceVersion getSupportedSourceVersion() {
    return SourceVersion.latestSupported();
  }

  @Override
  public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
    ...
  }
}</code></pre>
<p>你看到在代码的第一行是<code>@AutoService(Processor.class)</code>，这是什么？这是一个其他注解处理器中引入的注解。<code>AutoService</code>注解处理器是Google开发的，用来生成<code>META-INF/services/javax.annotation.processing.Processor</code>文件的。是的，你没有看错，我们可以在注解处理器中使用注解。非常方便，难道不是么？在<code>getSupportedAnnotationTypes()</code>中，我们指定本处理器将处理<code>@Factory</code>注解。</p>
<h2 id="Elements和TypeMirrors"><a href="#Elements和TypeMirrors" class="headerlink" title="Elements和TypeMirrors"></a>Elements和TypeMirrors</h2><p>在<code>init()</code>中我们获得如下引用：</p>
<ul>
<li><strong>Elements</strong>：一个用来处理<code>Element</code>的工具类（后面将做详细说明）；</li>
<li><strong>Types</strong>：一个用来处理<code>TypeMirror</code>的工具类（后面将做详细说明）；</li>
<li><strong>Filer</strong>：正如这个名字所示，使用Filer你可以创建文件。</li>
</ul>
<p>在注解处理过程中，我们扫描所有的Java源文件。源代码的每一个部分都是一个特定类型的<code>Element</code>。换句话说：<code>Element</code>代表程序的元素，例如包、类或者方法。每个<code>Element</code>代表一个静态的、语言级别的构件。在下面的例子中，我们通过注释来说明这个：</p>
<pre><code class="java">package com.example;    // PackageElement

public class Foo {        // TypeElement

    private int a;      // VariableElement
    private Foo other;  // VariableElement

    public Foo () {}    // ExecuteableElement

    public void setA (  // ExecuteableElement
                     int newA   // VariableElement
                     ) {}
}</code></pre>
<p>你必须换个角度来看源代码，它只是结构化的文本，他不是可运行的。你可以想象它就像你将要去解析的XML文件一样（或者是编译器中抽象的语法树）。就像XML解释器一样，有一些类似DOM的元素。你可以从一个元素导航到它的父或者子元素上。</p>
<p>举例来说，假如你有一个代表<code>public class Foo</code>类的<code>TypeElement</code>元素，你可以遍历它的孩子，如下：</p>
<pre><code class="java">TypeElement fooClass = ... ;  
for (Element e : fooClass.getEnclosedElements()){ // iterate over children  
    Element parent = e.getEnclosingElement();  // parent == fooClass
}</code></pre>
<p>正如你所见，<strong>Element</strong>代表的是源代码。<code>TypeElement</code>代表的是源代码中的类型元素，例如类。然而，<code>TypeElement</code>并不包含类本身的信息。你可以从<code>TypeElement</code>中获取类的名字，但是你获取不到类的信息，例如它的父类。这种信息需要通过<code>TypeMirror</code>获取。你可以通过调用<code>elements.asType()</code>获取元素的<code>TypeMirror</code>。</p>
<h2 id="搜索-Factory注解"><a href="#搜索-Factory注解" class="headerlink" title="搜索@Factory注解"></a>搜索@Factory注解</h2><p>我们来一步一步实现<code>process()</code>方法。首先，我们从搜索被注解了<code>@Factory</code>的类开始：</p>
<pre><code class="java">@AutoService(Processor.class)
public class FactoryProcessor extends AbstractProcessor {

  private Types typeUtils;
  private Elements elementUtils;
  private Filer filer;
  private Messager messager;
  private Map&lt;String, FactoryGroupedClasses&gt; factoryClasses = new LinkedHashMap&lt;String, FactoryGroupedClasses&gt;();
    ...

  @Override
  public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {

    // 遍历所有被注解了@Factory的元素
    for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) {
          ...
    }
  }
 ...
}</code></pre>
<p>这里并没有什么高深的技术。<code>roundEnv.getElementsAnnotatedWith(Factory.class))</code>返回所有被注解了<code>@Factory</code>的元素的列表。你可能已经注意到，我们并没有说“<em>所有被注解了<code>@Factory</code>的类的列表</em>”，因为它真的是返回<code>Element</code>的列表。请记住：<code>Element</code>可以是类、方法、变量等。所以，接下来，我们必须检查这些Element是否是一个类：</p>
<pre><code class="java">@Override
  public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {

    for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) {

      // 检查被注解为@Factory的元素是否是一个类
      if (annotatedElement.getKind() != ElementKind.CLASS) {
            ...
      }
   }
   ...
}</code></pre>
<p>为什么要这么做？我们要确保只有class元素被我们的处理器处理。前面我们已经学习到类是用<code>TypeElement</code>表示。我们为什么不这样判断呢<code>if (! (annotatedElement instanceof TypeElement) )</code>？这是错误的，因为接口（interface）类型也是TypeElement。所以在注解处理器中，我们要避免使用<code>instanceof</code>，而是配合<code>TypeMirror</code>使用<code>EmentKind</code>或者<code>TypeKind</code>。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>在<code>init()</code>中，我们也获得了一个<code>Messager</code>对象的引用。<code>Messager</code>提供给注解处理器一个报告错误、警告以及提示信息的途径。它不是注解处理器开发者的日志工具，而是用来写一些信息给使用此注解器的第三方开发者的。在<a href="http://docs.oracle.com/javase/7/docs/api/javax/tools/Diagnostic.Kind.html" target="_blank" rel="noopener">官方文档</a>中描述了消息的不同级别。非常重要的是<a href="http://docs.oracle.com/javase/7/docs/api/javax/tools/Diagnostic.Kind.html#ERROR" target="_blank" rel="noopener"><code>Kind.ERROR</code></a>，因为这种类型的信息用来表示我们的注解处理器处理失败了。很有可能是第三方开发者错误的使用了<code>@Factory</code>注解（例如，给接口使用了@Factory注解）。这个概念和传统的Java应用有点不一样，在传统Java应用中我们可能就抛出一个异常<code>Exception</code>。如果你在<code>process()</code>中抛出一个异常，那么运行注解处理器的JVM将会崩溃（就像其他Java应用一样），使用我们注解处理器FactoryProcessor第三方开发者将会从javac中得到非常难懂的出错信息，因为它包含FactoryProcessor的堆栈跟踪（Stacktace）信息。因此，注解处理器就有一个<code>Messager</code>类，它能够打印非常优美的错误信息。除此之外，你还可以连接到出错的元素。在像IntelliJ这种现代的IDE（集成开发环境）中，第三方开发者可以直接点击错误信息，IDE将会直接跳转到第三方开发者项目的出错的源文件的相应的行。</p>
<p>我们重新回到<code>process()</code>方法的实现。如果遇到一个非类类型被注解<code>@Factory</code>，我们发出一个出错信息：</p>
<pre><code class="java">public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {

    for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) {

      // 检查被注解为@Factory的元素是否是一个类
      if (annotatedElement.getKind() != ElementKind.CLASS) {
        error(annotatedElement, &quot;Only classes can be annotated with @%s&quot;,
            Factory.class.getSimpleName());
        return true; // 退出处理
      }
      ...
    }

private void error(Element e, String msg, Object... args) {  
    messager.printMessage(
        Diagnostic.Kind.ERROR,
        String.format(msg, args),
        e);
  }

}</code></pre>
<p>让Messager显示相关出错信息，更重要的是<strong>注解处理器程序必须完成运行而不崩溃</strong>，这就是为什么在调用<code>error()</code>后直接<code>return</code>。如果我们不直接返回，<code>process()</code>将继续运行，因为<code>messager.printMessage( Diagnostic.Kind.ERROR)</code>不会停止此进程。因此，如果我们在打印错误信息以后不返回的话，我们很可能就会运行到一个<em>NullPointerException</em>等。就像我们前面说的，如果我们继续运行<code>process()</code>，问题是如果在<code>process()</code>中抛出一个未处理的异常，javac将会打印出内部的<em>NullPointerException</em>，而不是<code>Messager</code>中的错误信息。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>在继续检查被注解@Fractory的类是否满足我们上面说的5条规则之前，我们将介绍一个让我们更方便继续处理的数据结构。有时候，一个问题或者解释器看起来如此简单，以至于程序员倾向于用一个面向过程方式来写整个处理器。但是你知道吗？一个注解处理器任然是一个Java程序，所以我们需要使用面向对象编程、接口、设计模式，以及任何你将在其他普通Java程序中使用的技巧。</p>
<p>我们的<code>FactoryProcessor</code>非常简单，但是我们仍然想要把一些信息存为对象。在<code>FactoryAnnotatedClass</code>中，我们保存被注解类的数据，比如合法的类的名字，以及@Factory注解本身的一些信息。所以，我们保存<code>TypeElement</code>和处理过的@Factory注解：</p>
<pre><code class="java">public class FactoryAnnotatedClass {

  private TypeElement annotatedClassElement;
  private String qualifiedSuperClassName;
  private String simpleTypeName;
  private String id;

  public FactoryAnnotatedClass(TypeElement classElement) throws IllegalArgumentException {
    this.annotatedClassElement = classElement;
    Factory annotation = classElement.getAnnotation(Factory.class);
    id = annotation.id();

    if (StringUtils.isEmpty(id)) {
      throw new IllegalArgumentException(
          String.format(&quot;id() in @%s for class %s is null or empty! that&#39;s not allowed&quot;,
              Factory.class.getSimpleName(), classElement.getQualifiedName().toString()));
    }

    // Get the full QualifiedTypeName
    try {
      Class&lt;?&gt; clazz = annotation.type();
      qualifiedSuperClassName = clazz.getCanonicalName();
      simpleTypeName = clazz.getSimpleName();
    } catch (MirroredTypeException mte) {
      DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror();
      TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement();
      qualifiedSuperClassName = classTypeElement.getQualifiedName().toString();
      simpleTypeName = classTypeElement.getSimpleName().toString();
    }
  }

  /**
   * 获取在{@link Factory#id()}中指定的id
   * return the id
   */
  public String getId() {
    return id;
  }

  /**
   * 获取在{@link Factory#type()}指定的类型合法全名
   *
   * @return qualified name
   */
  public String getQualifiedFactoryGroupName() {
    return qualifiedSuperClassName;
  }


  /**
   * 获取在 {@link Factory#type()} 中指定的类型的简单名字
   *
   * @return qualified name
   */
  public String getSimpleFactoryGroupName() {
    return simpleTypeName;
  }

  /**
   * 获取被@Factory注解的原始元素
   */
  public TypeElement getTypeElement() {
    return annotatedClassElement;
  }
}</code></pre>
<p>代码很多，但是最重要的部分是在构造函数中。其中你能找到如下的代码：</p>
<pre><code class="java">Factory annotation = classElement.getAnnotation(Factory.class);  
id = annotation.id(); // Read the id value (like &quot;Calzone&quot; or &quot;Tiramisu&quot;)

if (StringUtils.isEmpty(id)) {  
    throw new IllegalArgumentException(
          String.format(&quot;id() in @%s for class %s is null or empty! that&#39;s not allowed&quot;,
              Factory.class.getSimpleName(), classElement.getQualifiedName().toString()));
}</code></pre>
<p>这里我们获取@Factory注解，并且检查id是否为空？如果为空，我们将抛出<strong>IllegalArgumentException</strong>异常。你可能感到疑惑的是，前面我们说了不要抛出异常，而是使用<code>Messager</code>。这里仍然不矛盾。我们抛出内部的异常，你在将在后面看到会在<code>process()</code>中捕获这个异常。我这样做出于一下两个原因：</p>
<ol>
<li>我想示意我们应该像普通的Java程序一样编码。抛出和捕获异常是非常好的Java编程实践；</li>
<li>如果我们想要在<code>FactoryAnnotatedClass</code>中打印信息，我需要也传入<code>Messager</code>对象，并且我们在<strong>错误处理</strong>一节中已经提到，为了打印<code>Messager</code>信息，我们必须成功停止处理器运行。如果我们使用<code>Messager</code>打印了错误信息，我们怎样告知<code>process()</code>出现了错误呢？最容易，并且我认为最直观的方式就是抛出一个异常，然后让<code>process()</code>捕获之。</li>
</ol>
<p>接下来，我们将获取<code>@Fractory</code>注解中的<code>type</code>成员。我们比较关心的是合法的全名：</p>
<pre><code class="java">try {  
      Class&lt;?&gt; clazz = annotation.type();
      qualifiedGroupClassName = clazz.getCanonicalName();
      simpleFactoryGroupName = clazz.getSimpleName();
} catch (MirroredTypeException mte) {
      DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror();
      TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement();
      qualifiedGroupClassName = classTypeElement.getQualifiedName().toString();
      simpleFactoryGroupName = classTypeElement.getSimpleName().toString();
}</code></pre>
<p>这里有一点小麻烦，因为这里的类型是一个<code>java.lang.Class</code>。这就意味着，他是一个真正的Class对象。因为注解处理是在编译Java源代码之前。我们需要考虑如下两种情况：</p>
<ol>
<li><strong>这个类已经被编译</strong>：这种情况是：如果第三方<code>.jar</code>包含已编译的被@Factory注解<code>.class</code>文件。在这种情况下，我们可以想<code>try</code>中那块代码中所示直接获取<code>Class</code>。</li>
<li><strong>这个还没有被编译</strong>：这种情况是我们尝试编译被@Fractory注解的源代码。这种情况下，直接获取Class会抛出<code>MirroredTypeException</code>异常。幸运的是，MirroredTypeException包含一个<code>TypeMirror</code>，它表示我们未编译类。因为我们已经知道它必定是一个类类型（我们已经在前面检查过），我们可以直接强制转换为<code>DeclaredType</code>，然后读取<code>TypeElement</code>来获取合法的名字。</li>
</ol>
<p>好了，我们现在还需要一个数据结构<code>FactoryGroupedClasses</code>，它将简单的组合所有的<code>FactoryAnnotatedClasses</code>到一起。</p>
<pre><code class="java">public class FactoryGroupedClasses {

  private String qualifiedClassName;

  private Map&lt;String, FactoryAnnotatedClass&gt; itemsMap =
      new LinkedHashMap&lt;String, FactoryAnnotatedClass&gt;();

  public FactoryGroupedClasses(String qualifiedClassName) {
    this.qualifiedClassName = qualifiedClassName;
  }

  public void add(FactoryAnnotatedClass toInsert) throws IdAlreadyUsedException {

    FactoryAnnotatedClass existing = itemsMap.get(toInsert.getId());
    if (existing != null) {
      throw new IdAlreadyUsedException(existing);
    }

    itemsMap.put(toInsert.getId(), toInsert);
  }

  public void generateCode(Elements elementUtils, Filer filer) throws IOException {
    ...
  }
}</code></pre>
<p>正如你所见，这是一个基本的<code>Map&lt;String, FactoryAnnotatedClass&gt;</code>，这个映射表用来映射@Factory.id()到FactoryAnnotatedClass。我们选择<code>Map</code>这个数据类型，是因为我们要确保每个id是唯一的，我们可以很容易通过map查找实现。<code>generateCode()</code>方法将被用来生成工厂类代码（将在后面讨论）。</p>
<h2 id="匹配标准"><a href="#匹配标准" class="headerlink" title="匹配标准"></a>匹配标准</h2><p>我们继续实现<code>process()</code>方法。接下来我们想要检查被注解的类必须有只要一个公开的构造函数，不是抽象类，继承于特定的类型，以及是一个公开类：</p>
<pre><code class="java">public class FactoryProcessor extends AbstractProcessor {

  @Override
  public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {

    for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) {

      ...

      // 因为我们已经知道它是ElementKind.CLASS类型，所以可以直接强制转换
      TypeElement typeElement = (TypeElement) annotatedElement;

      try {
        FactoryAnnotatedClass annotatedClass =
            new FactoryAnnotatedClass(typeElement); // throws IllegalArgumentException

        if (!isValidClass(annotatedClass)) {
          return true; // 已经打印了错误信息，退出处理过程
         }
       } catch (IllegalArgumentException e) {
        // @Factory.id()为空
        error(typeElement, e.getMessage());
        return true;
       }
          ...
   }

 private boolean isValidClass(FactoryAnnotatedClass item) {

    // 转换为TypeElement, 含有更多特定的方法
    TypeElement classElement = item.getTypeElement();

    if (!classElement.getModifiers().contains(Modifier.PUBLIC)) {
      error(classElement, &quot;The class %s is not public.&quot;,
          classElement.getQualifiedName().toString());
      return false;
    }

    // 检查是否是一个抽象类
    if (classElement.getModifiers().contains(Modifier.ABSTRACT)) {
      error(classElement, &quot;The class %s is abstract. You can&#39;t annotate abstract classes with @%&quot;,
          classElement.getQualifiedName().toString(), Factory.class.getSimpleName());
      return false;
    }

    // 检查继承关系: 必须是@Factory.type()指定的类型子类
    TypeElement superClassElement =
        elementUtils.getTypeElement(item.getQualifiedFactoryGroupName());
    if (superClassElement.getKind() == ElementKind.INTERFACE) {
      // 检查接口是否实现了                                       if(!classElement.getInterfaces().contains(superClassElement.asType())) {
        error(classElement, &quot;The class %s annotated with @%s must implement the interface %s&quot;,
            classElement.getQualifiedName().toString(), Factory.class.getSimpleName(),
            item.getQualifiedFactoryGroupName());
        return false;
      }
    } else {
      // 检查子类
      TypeElement currentClass = classElement;
      while (true) {
        TypeMirror superClassType = currentClass.getSuperclass();

        if (superClassType.getKind() == TypeKind.NONE) {
          // 到达了基本类型(java.lang.Object), 所以退出
          error(classElement, &quot;The class %s annotated with @%s must inherit from %s&quot;,
              classElement.getQualifiedName().toString(), Factory.class.getSimpleName(),
              item.getQualifiedFactoryGroupName());
          return false;
        }

        if (superClassType.toString().equals(item.getQualifiedFactoryGroupName())) {
          // 找到了要求的父类
          break;
        }

        // 在继承树上继续向上搜寻
        currentClass = (TypeElement) typeUtils.asElement(superClassType);
      }
    }

    // 检查是否提供了默认公开构造函数
    for (Element enclosed : classElement.getEnclosedElements()) {
      if (enclosed.getKind() == ElementKind.CONSTRUCTOR) {
        ExecutableElement constructorElement = (ExecutableElement) enclosed;
        if (constructorElement.getParameters().size() == 0 &amp;&amp; constructorElement.getModifiers()
            .contains(Modifier.PUBLIC)) {
          // 找到了默认构造函数
          return true;
        }
      }
    }

    // 没有找到默认构造函数
    error(classElement, &quot;The class %s must provide an public empty default constructor&quot;,
        classElement.getQualifiedName().toString());
    return false;
  }
}</code></pre>
<p>我们这里添加了<code>isValidClass()</code>方法，来检查是否我们所有的规则都被满足了：</p>
<ul>
<li>必须是公开类：<code>classElement.getModifiers().contains(Modifier.PUBLIC)</code></li>
<li>必须是非抽象类：<code>classElement.getModifiers().contains(Modifier.ABSTRACT)</code></li>
<li>必须是<code>@Factoy.type()</code>指定的类型的子类或者接口的实现：首先我们使用<code>elementUtils.getTypeElement(item.getQualifiedFactoryGroupName())</code>创建一个传入的<code>Class</code>(<code>@Factoy.type()</code>)的元素。是的，你可以仅仅通过已知的合法类名来直接创建<code>TypeElement</code>（使用TypeMirror）。接下来我们检查它是一个接口还是一个类：<code>superClassElement.getKind() == ElementKind.INTERFACE</code>。所以我们这里有两种情况：如果是接口，就判断<code>classElement.getInterfaces().contains(superClassElement.asType())</code>；如果是类，我们就必须使用<code>currentClass.getSuperclass()</code>扫描继承层级。注意，整个检查也可以使用<code>typeUtils.isSubtype()</code>来实现。</li>
<li>类必须有一个公开的默认构造函数：我们遍历所有的闭元素<code>classElement.getEnclosedElements()</code>，然后检查<code>ElementKind.CONSTRUCTOR</code>、<code>Modifier.PUBLIC</code>以及<code>constructorElement.getParameters().size() == 0</code>。</li>
</ul>
<p>如果所有这些条件都满足，<code>isValidClass()</code>返回<code>true</code>，否者就打印错误信息，并且返回<code>false</code>。</p>
<h2 id="组合被注解的类"><a href="#组合被注解的类" class="headerlink" title="组合被注解的类"></a>组合被注解的类</h2><p>一旦我们检查<code>isValidClass()</code>成功，我们将添加<code>FactoryAnnotatedClass</code>到对应的<code>FactoryGroupedClasses</code>中，如下：</p>
<pre><code class="java">public class FactoryProcessor extends AbstractProcessor {

   private Map&lt;String, FactoryGroupedClasses&gt; factoryClasses =
      new LinkedHashMap&lt;String, FactoryGroupedClasses&gt;();


 @Override
  public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
      ...
      try {
        FactoryAnnotatedClass annotatedClass =
            new FactoryAnnotatedClass(typeElement); // throws IllegalArgumentException

          if (!isValidClass(annotatedClass)) {
          return true; // 错误信息被打印，退出处理流程
        }

        // 所有检查都没有问题，所以可以添加了
        FactoryGroupedClasses factoryClass =
        factoryClasses.get(annotatedClass.getQualifiedFactoryGroupName());
        if (factoryClass == null) {
          String qualifiedGroupName = annotatedClass.getQualifiedFactoryGroupName();
          factoryClass = new FactoryGroupedClasses(qualifiedGroupName);
          factoryClasses.put(qualifiedGroupName, factoryClass);
        }

        // 如果和其他的@Factory标注的类的id相同冲突，
        // 抛出IdAlreadyUsedException异常
        factoryClass.add(annotatedClass);
      } catch (IllegalArgumentException e) {
        // @Factory.id()为空 --&gt; 打印错误信息
        error(typeElement, e.getMessage());
        return true;
      } catch (IdAlreadyUsedException e) {
        FactoryAnnotatedClass existing = e.getExisting();
        // 已经存在
        error(annotatedElement,
            &quot;Conflict: The class %s is annotated with @%s with id =&#39;%s&#39; but %s already uses the same id&quot;,
            typeElement.getQualifiedName().toString(), Factory.class.getSimpleName(),
            existing.getTypeElement().getQualifiedName().toString());
        return true;
      }
    }
    ...
}</code></pre>
<h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>我们已经收集了所有的被<code>@Factory</code>注解的类保存到为<code>FactoryAnnotatedClass</code>，并且组合到了<code>FactoryGroupedClasses</code>。现在我们将为每个工厂生成Java文件了：</p>
<pre><code class="java">@Override
public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {  
    ...
  try {
        for (FactoryGroupedClasses factoryClass : factoryClasses.values()) {
          factoryClass.generateCode(elementUtils, filer);
        }
    } catch (IOException e) {
        error(null, e.getMessage());
    }

    return true;
}</code></pre>
<p>写Java文件，和写其他普通文件没有什么两样。使用<code>Filer</code>提供的<code>Writer</code>对象，我们可以连接字符串来写我们生成的Java代码。幸运的是，Square公司（因为提供了许多非常优秀的开源项目二非常有名）给我们提供了<a href="https://github.com/square/javawriter" target="_blank" rel="noopener"><code>JavaWriter</code></a>，这是一个高级的生成Java代码的库：</p>
<pre><code class="java">public class FactoryGroupedClasses {

  /**
   * 将被添加到生成的工厂类的名字中
   */
  private static final String SUFFIX = &quot;Factory&quot;;

  private String qualifiedClassName;

  private Map&lt;String, FactoryAnnotatedClass&gt; itemsMap =
      new LinkedHashMap&lt;String, FactoryAnnotatedClass&gt;();
    ...

  public void generateCode(Elements elementUtils, Filer filer) throws IOException {

    TypeElement superClassName = elementUtils.getTypeElement(qualifiedClassName);
    String factoryClassName = superClassName.getSimpleName() + SUFFIX;

    JavaFileObject jfo = filer.createSourceFile(qualifiedClassName + SUFFIX);
    Writer writer = jfo.openWriter();
    JavaWriter jw = new JavaWriter(writer);

    // 写包名
    PackageElement pkg = elementUtils.getPackageOf(superClassName);
    if (!pkg.isUnnamed()) {
      jw.emitPackage(pkg.getQualifiedName().toString());
      jw.emitEmptyLine();
    } else {
      jw.emitPackage(&quot;&quot;);
    }

    jw.beginType(factoryClassName, &quot;class&quot;, EnumSet.of(Modifier.PUBLIC));
    jw.emitEmptyLine();
    jw.beginMethod(qualifiedClassName, &quot;create&quot;, EnumSet.of(Modifier.PUBLIC), &quot;String&quot;, &quot;id&quot;);

    jw.beginControlFlow(&quot;if (id == null)&quot;);
    jw.emitStatement(&quot;throw new IllegalArgumentException(\&quot;id is null!\&quot;)&quot;);
    jw.endControlFlow();

    for (FactoryAnnotatedClass item : itemsMap.values()) {
      jw.beginControlFlow(&quot;if (\&quot;%s\&quot;.equals(id))&quot;, item.getId());
      jw.emitStatement(&quot;return new %s()&quot;, item.getTypeElement().getQualifiedName().toString());
      jw.endControlFlow();
      jw.emitEmptyLine();
    }

    jw.emitStatement(&quot;throw new IllegalArgumentException(\&quot;Unknown id = \&quot; + id)&quot;);
    jw.endMethod();
    jw.endType();
    jw.close();
  }
}</code></pre>
<blockquote>
<p>注意：因为JavaWriter非常非常的流行，所以很多处理器、库、工具都依赖于JavaWriter。如果你使用依赖管理工具，例如maven或者gradle，假如一个库依赖的JavaWriter的版本比其他的库新，这将会导致一些问题。所以我建议你直接拷贝重新打包JavaWiter到你的注解处理器代码中（实际它只是一个Java文件）。</p>
</blockquote>
<p><strong>更新</strong>：JavaWrite现在已经被<a href="https://github.com/square/javapoet" target="_blank" rel="noopener"><code>JavaPoet</code></a>取代了。</p>
<h2 id="处理循环"><a href="#处理循环" class="headerlink" title="处理循环"></a>处理循环</h2><p>注解处理过程可能会多于一次。官方javadoc定义处理过程如下：</p>
<blockquote>
<p>注解处理过程是一个有序的循环过程。在每次循环中，一个处理器可能被要求去处理那些在上一次循环中产生的源文件和类文件中的注解。第一次循环的输入是运行此工具的初始输入。这些初始输入，可以看成是虚拟的第0此的循环的输出。</p>
</blockquote>
<p>一个简单的定义：一个处理循环是调用一个注解处理器的<code>process()</code>方法。对应到我们的工厂模式的例子中：<code>FactoryProcessor</code>被初始化一次（不是每次循环都会新建处理器对象），然而，如果生成了新的源文件<code>process()</code>能够被调用多次。听起来有点奇怪不是么？原因是这样的，这些生成的文件中也可能包含@Factory注解，它们还将会被<code>FactoryProcessor</code>处理。</p>
<p>例如我们的<code>PizzaStore</code>的例子中将会经过3次循环处理：</p>
<table>
<thead>
<tr>
<th align="left">Round</th>
<th align="left">Input</th>
<th align="left">Output</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">CalzonePizza.java Tiramisu.java MargheritaPizza.java Meal.java PizzaStore.java</td>
<td align="left">MealFactory.java</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">MealFactory.java</td>
<td align="left">— none —</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">— none —</td>
<td align="left">— none —</td>
</tr>
</tbody></table>
<p>我解释处理循环还有另外一个原因。如果你看一下我们的<code>FactoryProcessor</code>代码你就能注意到，我们收集数据和保存它们在一个私有的域中<code>Map&lt;String, FactoryGroupedClasses&gt; factoryClasses</code>。在第一轮中，我们检测到了MagheritaPizza, CalzonePizza和Tiramisu，然后生成了MealFactory.java。在第二轮中把MealFactory作为输入。因为在MealFactory中没有检测到@Factory注解，我们预期并没有错误，然而我们得到如下的信息：</p>
<pre><code class="bash">Attempt to recreate a file for type com.hannesdorfmann.annotationprocessing101.factory.MealFactory  </code></pre>
<p>这个问题是因为我们没有清除<code>factoryClasses</code>，这意味着，在第二轮的<code>process()</code>中，任然保存着第一轮的数据，并且会尝试生成在第一轮中已经生成的文件，从而导致这个错误的出现。在我们的这个场景中，我们知道只有在第一轮中检查<code>@Factory</code>注解的类，所以我们可以简单的修复这个问题，如下：</p>
<pre><code class="java">@Override
public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {  
    try {
      for (FactoryGroupedClasses factoryClass : factoryClasses.values()) {
        factoryClass.generateCode(elementUtils, filer);
      }

      // 清除factoryClasses
      factoryClasses.clear();

    } catch (IOException e) {
      error(null, e.getMessage());
    }
    ...
    return true;
}</code></pre>
<p>我知道这有其他的方法来处理这个问题，例如我们也可以设置一个布尔值标签等。关键的点是：我们要记住注解处理过程是需要经过多轮处理的，并且你不能重载或者重新创建已经生成的源代码。</p>
<h2 id="分离处理器和注解"><a href="#分离处理器和注解" class="headerlink" title="分离处理器和注解"></a>分离处理器和注解</h2><p>如果你已经看了我们的<a href="https://github.com/sockeqwe/annotationprocessing101/tree/master/factory" target="_blank" rel="noopener">代码库</a>，你将发现我们组织我们的代码到两个maven模块中了。我们这么做是因为，我们想让我们的工厂模式的例子的使用者，在他们的工程中只编译注解，而包含处理器模块只是为了编译。有点晕？我们举个例子，如果我们只有一个包。如果另一个开发者想要把我们的工厂模式处理器用于他的项目中，他就必须包含<code>@Factory</code>注解和整个<code>FactoryProcessor</code>的代码（包括FactoryAnnotatedClass和FactoryGroupedClasses）到他们项目中。我非常确定的是，他并不需要在他已经编译好的项目中包含处理器相关的代码。如果你是一个Android的开发者，你肯定听说过65k个方法的限制（即在一个.dex文件中，只能寻址65000个方法）。如果你在FactoryProcessor中使用guava，并且把注解和处理器打包在一个包中，这样的话，Android APK安装包中不只是包含FactoryProcessor的代码，而也包含了整个guava的代码。Guava有大约20000个方法。所以分开注解和处理器是非常有意义的。</p>
<h2 id="生成的类的实例化"><a href="#生成的类的实例化" class="headerlink" title="生成的类的实例化"></a>生成的类的实例化</h2><p>你已经看到了，在这个<code>PizzaStore</code>的例子中，生成了<code>MealFactory</code>类，它和其他手写的Java类没有任何区别。进而，你需要就想其他Java对象，手动实例化 它：</p>
<pre><code class="java">public class PizzaStore {

  private MealFactory factory = new MealFactory();

  public Meal order(String mealName) {
    return factory.create(mealName);
  }
  ...
}</code></pre>
<p>如果你是一个Android的开发者，你应该也非常熟悉一个叫做<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener"><code>ButterKnife</code></a>的注解处理器。在ButterKnife中，你使用<code>@InjectView</code>注解Android的View。ButterKnifeProcessor生成一个<code>MyActivity$$ViewInjector</code>，但是在ButterKnife你不需要手动调用<code>new MyActivity$$ViewInjector()</code>实例化一个ButterKnife注入的对象，而是使用<code>Butterknife.inject(activity)</code>。ButterKnife内部使用反射机制来实例化<code>MyActivity$$ViewInjector()</code>对象：</p>
<pre><code class="java">try {  
    Class&lt;?&gt; injector = Class.forName(clsName + &quot;$$ViewInjector&quot;);
} catch (ClassNotFoundException e) { ... }</code></pre>
<p>但是反射机制不是很慢么，我们使用注解处理来生成本地代码，会不会导致很多的反射性能的问题？的确，反射机制的性能确实是一个问题。然而，它不需要手动去创建对象，确实提高了开发者的开发速度。ButterKnife中有一个哈希表HashMap来<strong>缓存</strong>实例化过的对象。所以<code>MyActivity$$ViewInjector</code>只是使用反射机制实例化一次，第二次需要<code>MyActivity$$ViewInjector</code>的时候，就直接冲哈希表中获得。</p>
<p><a href="https://github.com/sockeqwe/fragmentargs" target="_blank" rel="noopener"><code>FragmentArgs</code></a>非常类似于ButterKnife。它使用反射机制来创建对象，而不需要开发者手动来做这些。FragmentArgs在处理注解的时候生成一个特别的查找表类，它其实就是一种哈希表，所以整个FragmentArgs库只是在第一次使用的时候，执行一次反射调用，一旦整个<code>Class.forName()</code>的Fragemnt的参数对象被创建，后面的都是本地代码运行了。</p>
<p>作为一个注解注解处理器的开发者，这些都由你来决定，为其他的注解器使用者，在反射和可用性上找到一个好的平衡。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此，我希望你对注解处理过程有一个非常深刻的理解。我必须再次说明一下：注解处理器是一个非常强大的工具，减少了很多无聊的代码的编写。我也想提醒的是，注解处理器可以做到比我上面提到的工厂模式的例子复杂很多的事情。例如，泛型的类型擦除，因为注解处理器是发生在类型擦除（type erasure）之前的（译者注：类型擦除可以参考<a href="http://justjavac.iteye.com/blog/1741638" target="_blank" rel="noopener">这里</a>）。就像你所看到的，你在写注解处理的时候，有两个普遍的问题你需要处理：第一问题， 如果你想在其他类中使用ElementUtils, TypeUtils和Messager，你就必须把他们作为参数传进去。在我为Android开发的注解器<a href="https://github.com/sockeqwe/AnnotatedAdapter" target="_blank" rel="noopener"><code>AnnotatedAdapter</code></a>中，我尝试使用Dagger（一个依赖注入库）来解决这个问题。在这个简单的处理中使用它听起来有点过头了，但是它确实很好用；第二个问题，你必须做<strong>查询</strong><code>Elements</code>的操作。就想我之前提到的，处理Element就解析XML或者HTML一样。对于HTML你可以是用jQuery，如果在注解处理器中，有类似于jQuery的库那那绝对是酷毙了。如果你知道有类似的库，请在下面的评论告诉我。</p>
<p>请注意的是，在FactoryProcessor代码中有一些缺陷和陷阱。这些“错误”是我故意放进去的，是为了演示一些在开发过程中的常见错误（例如“Attempt to recreate a file”）。如果你想基于FactoryProcessor写你自己注解处理器，请<strong>不要</strong>直接拷贝粘贴这些陷阱过去，你应该从最开始就避免它们。</p>
<p>我在后续的博客中将会写注解处理器的单元测试，敬请关注。</p>
<hr>
<p>翻译到此结束。文章确实太长了，花了我好几天的时间，如果翻译过程中有什么错误，请指出来，也可以参考作者的<a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101/" target="_blank" rel="noopener">原文</a>。翻译不容易，写这篇文章的原作者更不容易。能够在这种优秀的博文中，学习到作者的认真的态度也是很值得的。</p>


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          <li class="previous">
            <a href="/2021/04/06/java-reflect/" data-toggle="tooltip" data-placement="top" title="【转载】大白话说Java反射：入门、使用、原理">&larr; Previous Post</a>
          </li>
          
          
          <li class="next">
            <a href="/2021/03/31/kotlin-learning-18-apt/" data-toggle="tooltip" data-placement="top" title="Kotlin 修炼手册（18）注解处理器（APT）">Next Post &rarr;</a>
          </li>
          
        </ul>

        
        <!-- tip start -->
        <!-- tip -->
<!-- tip start -->
<div class="tip">
  <p>
    
      If you like this blog or find it useful for you, you are welcome to comment on it. You are also welcome to share this blog, so that more people can participate in it. If the images used in the blog infringe your copyright, please contact the author to delete them. Thank you !
    
  </p>
</div>
<!-- tip end -->

        <!-- tip end -->
        

        
        <!-- Sharing Srtart -->
        <!-- Social Social Share Post -->
<!-- Docs:https://github.com/overtrue/share.js -->

<div class="social-share" data-initialized="true" data-disabled="tencent ,douban ,qzone ,linkedin ,facebook ,google ,diandian" data-wechat-qrcode-helper="" align="center">
  <ul class="list-inline text-center social-share-ul">
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-twitter">
        <i class="fa fa-twitter fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a class="social-share-icon icon-wechat">
        <i class="fa fa-weixin fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-weibo">
        <i class="fa fa-weibo fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-qq">
        <i class="fa fa-qq fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon" href="mailto:?subject=【转载】Java 注解处理器&body=Hi,I found this website and thought you might like it http://yoursite.com/2021/03/31/java-apt/">
        <i class="fa fa-envelope fa-1x" aria-hidden="true"></i>
      </a>
    </li>
  </ul>
</div>

<!-- css & js -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"> -->
<script defer="defer" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

        <!-- Sharing End -->
        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

  <!-- gitalk start -->
  <!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

  <div id="gitalk-container"></div>

  
    <!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.js"></script> -->
    <script src="/js/comment/gitalk.js"></script>
  

  <script>
    var gitalk = new Gitalk({
      clientID: '3b44fc2839a6c19bfea7',
      clientSecret: 'b96f2147e01e0d906403b6af8518a8e1f04a46de',
      repo: 'blogcomments',
      owner: 'owenleexiaoyu',
      admin: 'owenleexiaoyu',
      id: 'Wed Mar 31 2021 13:00:00 GMT+0800', // Ensure uniqueness and length less than 50
      distractionFreeMode: false, // Facebook-like distraction free mode
      perPage: 10,
      pagerDirection: 'last',
      createIssueManually: false,
      language: 'en',
      proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    });
    gitalk.render('gitalk-container');

    var gtFolded = () => {
      setTimeout(function () {
        let markdownBody = document.getElementsByClassName("markdown-body");
        let list = Array.from(markdownBody);
        list.forEach(item => {
          if (item.clientHeight > 250) {
            item.classList.add('gt-comment-body-folded');
            item.style.maxHeight = '250px';
            item.title = 'Click to Expand';
            item.onclick = function () {
              item.classList.remove('gt-comment-body-folded');
              item.style.maxHeight = '';
              item.title = '';
              item.onclick = null;
            };
          }
        })
      }, 800);
    }
  </script>

  <!-- gitalk end -->


<!-- 2. gitment comment -->


<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->



      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">FEATURED TAGS</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#Java" title="Java">Java</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
      </div>
    </div>
  </div>
</article>





		<!-- Footer (contains ThemeColor、viewer) -->
		<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          
            <li>
              <a target="_blank" href="https://github.com/owenleexiaoyu">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          

          

          

          

          

          
            <li>
              <a target="_blank" href="http://weibo.com/李大鱼呵呵哒">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          Owen Lee
          2021
          <br>
          Theme by
          <a href="http://beantech.org">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a href="https://v-vincen.life/">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>


  <!-- jQuery -->
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <!-- Bootstrap Core JavaScript -->
  <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  <!-- Custom Theme JavaScript -->
  <script type="text/javascript" src="/js/hux-blog.min.js"></script>
  <!-- catalog -->
  <script async="true" type="text/javascript" src="/js/catalog.js"></script>
  <!-- totop(rocket) -->
  <script async="true" type="text/javascript" src="/js/totop.js"></script>

  
    <!-- Busuanzi JavaScript -->
    <script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  

  

  

  

  






  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  
    <script async="async" type="text/javascript" src="/js/viewer/viewer.min.js"></script>
    <script async="async" type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
  

  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async ("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () { hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if ($('#tag_cloud').length !== 0) { async ("http://yoursite.com/js/jquery.tagcloud.js", function () { $.fn.tagcloud.defaults = { // size: { start: 1, end: 1, unit: 'em' }, color: {
start: '#bbbbee', end: '#0085a1' } }; $('#tag_cloud a').tagcloud(); }) } </script> -->


		<!-- Search -->
		
	</body>
</html>
